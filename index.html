<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dash Boom â€” Pixel Explosion</title>
<style>
body { margin:0; background:#111; font-family: pixel, monospace; overflow:hidden; }
@font-face { font-family: pixel; src: local("Courier New"), local("monospace"); }

#menu, #gameOverMenu {
    position: absolute; top:0; left:0; width:100%; height:100%;
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    background: linear-gradient(#8acbff,#3b6ccc); color:white; font-size:50px; letter-spacing:3px; z-index:10; image-rendering: pixelated;
}

#playBtn, #restartBtn, #quitBtn {
    margin-top: 20px; padding:15px 40px; font-size:45px; background:#1b4fbf; border:4px solid #fff; cursor:pointer; image-rendering: pixelated;
}

canvas { background:#8acbff; image-rendering: pixelated; display:block; margin:auto; }
</style>
</head>
<body>
<div id="menu">
    <div>DASH BOOM</div>
    <button id="playBtn">PLAY</button>
</div>

<div id="gameOverMenu" style="display:none;">
    <div>GAME OVER</div>
    <button id="restartBtn">RESTART</button>
    <button id="quitBtn">QUIT</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gameRunning = false;
let score = 0;
let highScore = parseInt(localStorage.getItem("dashboom_highscore")||"0");
let obstacles = [];
let spawnInterval = null;
let lastTime = 0;

// ===== PLAYER =====
const player = { x: canvas.width/2, y: canvas.height/2, size:50, speed:8 };
let pointer = { x: player.x, y: player.y, active:false };
let trail = [];

canvas.addEventListener("touchstart", e => { pointer.active=true; let t=e.touches[0]; let r=canvas.getBoundingClientRect(); pointer.x=t.clientX-r.left; pointer.y=t.clientY-r.top; });
canvas.addEventListener("touchmove", e => { let t=e.touches[0]; let r=canvas.getBoundingClientRect(); pointer.x=t.clientX-r.left; pointer.y=t.clientY-r.top; });
canvas.addEventListener("touchend", ()=> pointer.active=false);

// ===== PLAYER MOVEMENT & TRAIL =====
function updatePlayer() {
    if (!pointer.active) return;
    let dx = pointer.x - player.x;
    let dy = pointer.y - player.y;
    player.x += dx * 0.15;
    player.y += dy * 0.15;
    player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
    player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));

    trail.push({x:player.x+player.size/2, y:player.y+player.size/2, alpha:1});
    if (trail.length>20) trail.shift();
}

function drawPlayer() {
    for (let t of trail) {
        ctx.fillStyle = `rgba(255,215,0,${t.alpha})`;
        ctx.fillRect(t.x-25,t.y-25,player.size,player.size);
        t.alpha-=0.05;
    }
    ctx.fillStyle="#ffd700";
    ctx.fillRect(player.x,player.y,player.size,player.size);
    ctx.fillStyle="#000";
    ctx.fillRect(player.x+12,player.y+15,8,8);
    ctx.fillRect(player.x+30,player.y+15,8,8);
    ctx.fillRect(player.x+18,player.y+32,15,5);
}

// ===== OBSTACLES =====
function spawnObstacle() {
    if (obstacles.length >= 17) return;
    let size = 30+Math.random()*20;
    let speed = 2+Math.random()*4 + score/100;
    let type = Math.random()<0.5?"normal":"zigzag";
    const side = Math.floor(Math.random()*4);
    let o = { w:size, h:size, vx:0, vy:0, type, t:0, dir: Math.random()<0.5?-1:1 };
    if(side===0){ o.x=Math.random()*canvas.width; o.y=-size; o.vy=speed; }
    else if(side===1){ o.x=Math.random()*canvas.width; o.y=canvas.height+size; o.vy=-speed; }
    else if(side===2){ o.x=-size; o.y=Math.random()*canvas.height; o.vx=speed; }
    else{ o.x=canvas.width+size; o.y=Math.random()*canvas.height; o.vx=-speed; }
    obstacles.push(o);
}

function updateObstacles(dt) {
    obstacles.forEach(o=>{
        if(o.type==="zigzag"){
            o.t+=dt*10;
            if(o.vx===0) o.x+=Math.sin(o.t)*3;
            else o.y+=Math.sin(o.t)*3;
        }
        o.x+=o.vx*dt*60;
        o.y+=o.vy*dt*60;
    });
    obstacles = obstacles.filter(o => o.x<canvas.width+100 && o.x>-100 && o.y<canvas.height+100 && o.y>-100);
}

function drawObstacles() {
    ctx.fillStyle="#444";
    obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));
}

// ===== COLLISION =====
function checkCollision() {
    for(let o of obstacles){
        if(player.x<o.x+o.w && player.x+player.size>o.x && player.y<o.y+o.h && player.y+player.size>o.y){
            ctx.fillStyle="rgba(255,0,0,0.5)";
            ctx.fillRect(0,0,canvas.width,canvas.height);
            gameOver();
        }
    }
}

// ===== SCORE =====
function drawScore() {
    ctx.fillStyle="#000";
    ctx.font="30px pixel";
    ctx.fillText("Score: "+Math.floor(score),20,40);
    ctx.fillText("Best: "+Math.floor(highScore),canvas.width-180,40);
}

// ===== GAME LOOP =====
function gameLoop(t) {
    if(!gameRunning) return;
    let dt=(t-lastTime)/1000;
    lastTime=t;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    updatePlayer();
    updateObstacles(dt);
    checkCollision();
    drawObstacles();
    drawPlayer();
    drawScore();
    score+=dt*10;
    requestAnimationFrame(gameLoop);
}

// ===== GAME OVER =====
function gameOver() {
    gameRunning=false;
    highScore=Math.max(highScore,score);
    localStorage.setItem("dashboom_highscore",highScore);
    document.getElementById("gameOverMenu").style.display="flex";
    if(spawnInterval){ clearInterval(spawnInterval); spawnInterval=null; }
}

// ===== BUTTONS =====
document.getElementById("playBtn").onclick = startGame;
document.getElementById("restartBtn").onclick = startGame;
document.getElementById("quitBtn").onclick = () => {
    document.getElementById("gameOverMenu").style.display="none";
    document.getElementById("menu").style.display="flex";
};

function startGame(){
    score=0;
    obstacles=[];
    player.x=canvas.width/2;
    player.y=canvas.height/2;
    trail.length=0;
    document.getElementById("menu").style.display="none";
    document.getElementById("gameOverMenu").style.display="none";
    gameRunning=true;
    lastTime=performance.now();
    spawnObstacle();
    spawnInterval=setInterval(spawnObstacle,800);
    gameLoop(lastTime);
}
</script>
</body>
</html>
